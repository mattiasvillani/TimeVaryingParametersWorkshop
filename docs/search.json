[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Workshop on time-varying parameter models",
    "section": "",
    "text": "Star\n\nHalf-day workshop at University of Technology Sydney (UTS)\n\n\nAim\nThe aim of the workshop is to give an introduction to time-varying parameter models and Bayesian inference for such models, with an outlook to some new developments. The workshop consists of lectures on the models, theory and computations, with some light demos in R. The participants are expected to leave the workshop with enough knowledge to solve the computer lab exercises by themselves after the workshop.\n\n\nInstructor\n\nMattias Villani Professor of Statistics Stockholm University\n\n\nPrerequisites\n\nBasic knowledge of Bayesian statistics is assumed.\nFamiliarity with Markov Chain Monte Carlo (MCMC) is needed for some parts of the workshop.\nBasic knowledge of R is needed to follow along in the demos (although this is a small part of the workshop).\n\n\n\nBefore the workshop\nIt is not necessary to bring your own laptop, but if you want to follow along in the demos, participants are encouraged to:\n\nInstall R and RStudio\nInstall the dlm package in R\n\n\n\nPlan and material\n\nLecture 1 - Time-varying parameter models and state-space models Reading: Bayesian Learning - Chapter 17 | Slides Interactivity: local level | local trend | time-varying regression\nLecture 2 - Inference in linear Gaussian models Reading: Bayesian Learning - Chapter 17 | Slides - TBA Code: demo of the dlm package in R Interactivity: filtering local level | nile river data\nLecture 3 - Inference in non-linear and non-Gaussian models Reading: Slides - TBA Interactivity: poisson time series | stochastic volatility\nLecture 4 - Global-local shrinkage processes for more realistic parameter evolutions Reading: Slides - TBA Interactivity: local level model with dsp prior | poisson with dsp prior\nComputer lab computer lab - TBA"
  },
  {
    "objectID": "demos/dlm_package.html",
    "href": "demos/dlm_package.html",
    "title": "Demo - the dlm package for state-space models in R",
    "section": "",
    "text": "This notebook illustrates the use of the dlm package in R. How to set up a state-space model, and how to do Kalman filtering, smoothing and forecasting. The local level model for the well-known Nile river data is used as the running example. The final bonus section shows how the Kalman filter is implemented from scratch in R."
  },
  {
    "objectID": "demos/dlm_package.html#local-level-model",
    "href": "demos/dlm_package.html#local-level-model",
    "title": "Demo - the dlm package for state-space models in R",
    "section": "Local level model",
    "text": "Local level model\nThe local level model has a constantly changing mean following a random walk model:\n\\[y_t = \\mu_t + \\varepsilon_t,\\qquad \\varepsilon_t \\sim N(0,\\sigma_\\varepsilon^2)\\]\n\\[\\mu_t = \\mu_{t-1} + \\eta_t,\\qquad \\eta_t \\sim N(0,\\sigma_\\eta^2)\\]\nwhich models the observed time series \\(y_t\\) as a mean \\(\\mu_t\\) plus a random measurement error or disturbance \\(\\varepsilon_t\\). The mean \\(\\mu_t\\) evolves over time as a random walk driven by innovations \\(\\eta_t\\)."
  },
  {
    "objectID": "demos/dlm_package.html#the-dlm-package-in-r",
    "href": "demos/dlm_package.html#the-dlm-package-in-r",
    "title": "Demo - the dlm package for state-space models in R",
    "section": "The dlm package in R",
    "text": "The dlm package in R\nThe dlm package uses the following notation for a state-space model for a univariate time series \\(y_t\\) with a state vector \\(\\boldsymbol{\\theta}_t\\):\n\\[\n\\begin{align}\ny_t &= \\boldsymbol{F} \\boldsymbol{\\theta}_t + v_t,\\hspace{1.5cm} v_t \\sim N(\\boldsymbol{0},\\boldsymbol{v})  \\\\\n\\boldsymbol{\\theta}_t &= \\boldsymbol{G} \\boldsymbol{\\theta}_{t-1} + \\boldsymbol{w}_t, \\qquad \\boldsymbol{w}_t \\sim N(\\boldsymbol{0},\\boldsymbol{W})\n\\end{align}\n\\]\nFor example, the local level model is a state-space model with a single scalar state variable \\(\\boldsymbol{\\theta}_t = \\mu_t\\) and parameters\n\\[\n\\begin{align}\n\\boldsymbol{F} &= 1 \\\\\n\\boldsymbol{G} &= 1  \\\\\n\\boldsymbol{V} &= \\sigma_\\varepsilon^2 \\\\\n\\boldsymbol{W} &= \\sigma_\\eta^2\n\\end{align}\n\\]\nThe dlm package is a user-friendly R package for analyzing some state-space models. The package has a nice vignette that is worth reading if you plan to use the package more seriously.\n\nFiltering\nLet’s first do some filtering in the dlm package. Start by loading the dlm package:\n\n#install.packages(\"dlm\") # uncomment the first time to install.\nlibrary(dlm)\n\nWe now need to tell the dlm package what kind of state-space model we want to estimate. The means setting up the matrices \\(\\boldsymbol{F}\\), \\(\\boldsymbol{G}\\), \\(\\boldsymbol{V}\\) and \\(\\boldsymbol{W}\\) for the local level model. We will first set the two static parameters to: \\(\\sigma_\\varepsilon^2 = 100^2\\) and \\(\\sigma_\\eta^2 = 100^2\\). Later we estimate these parameters by maximum likelihood. Here is how you setup the local level model in the dlm package:\n\nmodel = dlm(FF = 1, V = 100^2, GG = 1, W = 100^2, m0 = 1000, C0 = 1000^2)\n\nThe two last arguments to the dlm function is the prior mean (m0) and (co)variance (C0) for the state at time \\(t=0\\).\nCompute the filtering estimate using the Kalman filter and plot the result\n\nnileFilter &lt;- dlmFilter(Nile, model)\nplot(Nile, type = 'l', col = \"steelblue\")\nlines(dropFirst(nileFilter$m), type = 'l', col = \"orange\")\nlegend(\"bottomleft\", legend = c(\"Observed\", \"Filtered\"), lty = 1, \n    col = c(\"steelblue\", \"orange\"))\n\n\n\n\n\n\n\n\nThe dlm package also infers the initial value of the state at time \\(t=0\\). By using the dropFirst command we only plot the filtering posterior for \\(t=1,\\ldots,T\\).\n\n\nParameter estimation by maximum likelihood\nThe parameters \\(\\sigma_\\varepsilon^2\\) and \\(\\sigma_\\eta^2\\) were just set to some values above. The function dlmMLE estimates these parameters by maximum likelihood, but we need to set up a model build object so the dlm package knows which parameter to estimate. We reparameterize the two variances using the exponential function to ensure that the estimated variances are positive.\n\n modelBuild &lt;- function(param) {\n   dlm(FF = 1, V = exp(param[1]), GG = 1, W = exp(param[2]), m0 = 1000, C0 = 1000^2)\n }\n fit &lt;- dlmMLE(Nile, parm = c(0,0), build = modelBuild)\n\nwhere parm is a vector with initial values for the two parameters (on the log scale, since we use exponential functions to ensure positive variances).\nWe need to take the exponential of the MLEs to get the estimated variance parameters.\n\n exp(fit$par)\n\n[1] 15101.339  1467.049\n\n\nor the square roots, to get the maximum likelihood estimates of the standard deviations\n\nsqrt(exp(fit$par))\n\n[1] 122.88750  38.30208\n\n\nWe can redo the filtering, this time using the maximum likelihood estimates of the parameters:\n\nmodel_mle = dlm(FF = 1, V = exp(fit$par[1]), GG = 1, W = exp(fit$par[2]), m0 = 1000, C0 = 1000^2)\nnileFilter &lt;- dlmFilter(Nile, model_mle)\nplot(Nile, type = 'l', col = \"steelblue\", lwd = 1.5)\nlines(dropFirst(nileFilter$m), type = 'l', col = \"orange\", lwd = 1.5)\nlegend(\"bottomleft\", legend = c(\"Observed\", \"Filtered\"), lwd = 1.5, lty = 1, \n    col = c(\"steelblue\", \"orange\"))\n\n\n\n\n\n\n\n\n\n\nSmoothing\nWe can also use the dlm package to compute the smoothed retrospective estimates of the local level \\(\\mu_t\\) at time \\(t\\) using all the data from \\(t=1\\) until the end of the time series \\(T\\). Here is the smoothing results for the Nile data, using the function dlmSmooth from the dlm package. The filtered estimates are also shown.\n\nnileSmooth &lt;- dlmSmooth(Nile, model_mle)\nplot(Nile, type = 'l', col = \"steelblue\", lwd = 1.5)\nlines(dropFirst(nileFilter$m), type = 'l', col = \"orange\", lwd = 1.5)\nlines(dropFirst(nileSmooth$s), type = 'l', col = \"red\", lwd = 1.5)\nlegend(\"bottomleft\", legend = c(\"Observed\", \"Filtered\",\"Smoothed\"), lty = 1, lwd = 1.5, col = c(\"steelblue\", \"orange\", \"red\"))\n\n\n\n\n\n\n\n\n\n\nForecasting\nWe can also use state-space models for forecasting. Here is how it is done in the dlm package.\n\nnileFore &lt;- dlmForecast(nileFilter, nAhead = 5)\nsqrtR &lt;- sapply(nileFore$R, function(x) sqrt(x))\npl &lt;- nileFore$a[,1] + qnorm(0.05, sd = sqrtR)\npu &lt;- nileFore$a[,1] + qnorm(0.95, sd = sqrtR)\nx &lt;- ts.union(window(Nile, start = c(1900, 1)),\n              window(nileSmooth$s, start = c(1900, 1)), \n              nileFore$a, pl, pu)\n\nplot(x, plot.type = \"single\", type = 'o', pch = c(NA, NA, NA, NA, NA), lwd = 1.5,\n     col = c(\"steelblue\", \"red\", \"brown\", \"gray\", \"gray\"),\n     ylab = \"River flow\")\nlegend(\"bottomleft\", legend = c(\"Observed\", \"Smoothed\", \"Forecast\", \n    \"90% probability limit\"), bty = 'n', pch = c(NA, NA, NA, NA, NA), lty = 1, lwd = 1.5,\n    col = c(\"steelblue\", \"red\", \"brown\", \"gray\", \"gray\"))"
  },
  {
    "objectID": "demos/dlm_package.html#bonus-implementing-the-kalman-filter-from-scratch",
    "href": "demos/dlm_package.html#bonus-implementing-the-kalman-filter-from-scratch",
    "title": "Demo - the dlm package for state-space models in R",
    "section": "Bonus: Implementing the Kalman filter from scratch",
    "text": "Bonus: Implementing the Kalman filter from scratch\nFor the curious, the code below implements the Kalman filter from scratch in R. Let us first implement a function kalmanfilter_update that does the update for a single time step:\n\nkalmanfilter_update &lt;- function(mu, Omega, y, G, C, V, W) {\n  \n  # Prediction step - moving state forward without new measurement\n  muPred &lt;- G %*% mu\n  omegaPred &lt;- G %*% Omega %*% t(G) + W\n  \n  # Measurement update - updating the N(muPred, omegaPred) prior with the new data point\n  K &lt;- omegaPred %*% t(F) / (F %*% omegaPred %*% t(F) + V) # Kalman Gain\n  mu &lt;- muPred + K %*% (y - F %*% muPred)\n  Omega &lt;- (diag(length(mu)) - K %*% F) %*% omegaPred\n  \n  return(list(mu, Omega))\n}\n\nThen we implement a function that does all the Kalman iterations, using the kalmanfilter_update function above:\n\nkalmanfilter &lt;- function(Y, G, F, V, W, mu0, Sigma0) {\n  T &lt;- dim(Y)[1]  # Number of time steps\n  n &lt;- length(mu0)  # Dimension of the state vector\n  \n  # Storage for the mean and covariance state vector trajectory over time\n  mu_filter &lt;- matrix(0, nrow = T, ncol = n)\n  Sigma_filter &lt;- array(0, dim = c(n, n, T))\n  \n  # The Kalman iterations\n  mu &lt;- mu0\n  Sigma &lt;- Sigma0\n  for (t in 1:T) {\n    result &lt;- kalmanfilter_update(mu, Sigma, t(Y[t, ]), G, F, V, W)\n    mu &lt;- result[[1]]\n    Sigma &lt;- result[[2]]\n    mu_filter[t, ] &lt;- mu\n    Sigma_filter[,,t] &lt;- Sigma\n  }\n  \n  return(list(mu_filter, Sigma_filter))\n}\n\nLet’s try it out on the Nile river data:\n\n# Analyzing the Nile river data\nprettycolors = c(\"#6C8EBF\", \"#c0a34d\", \"#780000\")\ny = as.vector(Nile)\nV = 100^2\nW = 100^2\nmu0 = 1000\nSigma0 = 1000^2\n\n# Set up state-space model for local level model\nT = length(y)\nG = 1\nF = 1\nY = matrix(0,T,1)\nY[,1] = y\nfilterRes = kalmanfilter(Y, G, F, V, W, mu0, Sigma0)\nmeanFilter = filterRes[[1]]\nstd_filter = sqrt(filterRes[[2]][,,, drop =TRUE])\n\nplot(seq(1:T), y, type = \"l\", col = prettycolors[1], lwd = 1.5, xlab = \"time, t\")\npolygon(c(seq(1:T), rev(seq(1:T))), \n        c(meanFilter - 1.96*std_filter, rev(meanFilter + 1.96*std_filter)), \n        col = \"#F0F0F0\", border = NA)\nlines(seq(1:T), y, type = \"l\", col = prettycolors[1], lwd = 1.5, xlab = \"time, t\")\nlines(seq(1:T), meanFilter, type = \"l\", col = prettycolors[3], lwd = 1.5)\nlegend(\"topright\", legend = c(\"time series\", \"filter mean\", \"95% intervals\"), lty = 1, lwd = 1.5,\n    col = c(prettycolors[1], prettycolors[3], \"#F0F0F0\"))"
  }
]